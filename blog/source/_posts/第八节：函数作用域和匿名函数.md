---
title: 第八节：函数作用域和匿名函数
tags:
  - 课后解答
url: 196.html
id: 196
categories:
  - 学习
  - 教学
date: 2018-05-08 14:45:20
---

\[info\]

python 使用 lambda 来创建匿名函数。
-------------------------

*   lambda只是一个表达式，函数体比def简单很多。
*   lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
*   lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。
*   虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

  形式：    函数名=lambda 参数：表达式                        等价于    def  函数名（参数）： 语句块 return 返回值

lambda作用域说明
-----------

关于变量在Lambda中的作用域主要可以做出以下几点的总结：

1.  对局部变量可见
2.  对全局变量可见
3.  对当前层传入的参数可见
4.  对上层函数传入的参数可见
5.  对上层Lambda传入的参数可见

  局部变量和全局变量：详见：[点我](https://blog.mviai.com/images/archives/193)  

闭包：
---

在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 条件： 1)必须有一个内嵌函数(函数里定义的函数）——这对应函数之间的嵌套 2)内嵌函数必须引用一个定义在闭合范围内(外部函数里)的变量——内部函数引用外部变量 3)外部函数必须返回内嵌函数——必须返回那个内部函数   陷阱： **返回函数千万不要引用任何一个循环变量,或者在之后会发生改变的变量.** bug代码如下：

1.  # 希望一次返回3个函数，分别计算1x1,2x2,3x3:  
2.  def count():  
3.      fs = \[\]  
4.      for i in range(1, 4):  
5.          def f():  
6.               return i*i  
7.          fs.append(f)  
8.      return fs  

10.  f1, f2, f3 = count()  

12.  print f1(), f2(), f3()  

改进：

1.  #coding:utf-8  
2.  \_\_author\_\_ = 'chad'  
3.  # 希望一次返回3个函数，分别计算1x1,2x2,3x3:  
4.  def count():  
5.      fs = \[\]  
6.      for i in range(1, 4):  
7.          def f(j):  
8.              def g():  
9.                  return j*j  
10.              return g  
11.          fs.append(f(i))  
12.      return fs  

14.  f1, f2, f3 = count()  

16.  print f1(), f2(), f3()  

递归（自己调用自己）：
-----------

来源于：数学归纳法 直接调用：

`def` `func():`

`print``(``'from func'``)`

`func()`

`func()`

间接调用：

`#间接调用自己`

`def` `foo():`

`print``(``'from foo'``)`

`bar()`

`def` `bar():`

`print``(``'from bar'``)`

`foo()`

`foo()`

典型递归：树结构，阶乘，斐波那契数列，汉诺塔

\[/info\]
