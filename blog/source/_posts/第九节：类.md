---
title: 第九节：类
tags:
  - 课后解答
url: 230.html
id: 230
categories:
  - 学习
  - 教学
date: 2018-05-12 22:15:10
---



类定义：
----

**用来描述具体相同的属性和方法的对象的集合。定义了该集合中每个对象所共有的属性和方法。对象是类的示例** `类 Class`: 用来描述具体相同的属性和方法的对象的集合。定义了该集合中每个对象所共有的属性和方法。对象是类的示例。 `类变量`：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 `数据成员`：类变量或者实例变量用于处理类及其实例对象的相关数据。 `方法重写`：如果从父类继承的方法不能满足子类的需求，可以对其 进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 `实例变量`：定义在方法中的变量，只作用于当前实例的类。 `继承`：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 `实例化`：创建一个类的实例，类的具体对象。就是将创建的类赋值给另一个变量。理解为赋值即可，a = class()，这个过程，就叫做实例化 `方法`：类中定义的函数。 `对象`：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

类有这样一些的优点
---------

1 ) 、类对象是多态的：也就是多种形态，这意味着我们可以对不同的类对象使用同样的操作方法，而不需要额外写代码。 2 ) 、类的封装：封装之后，可以直接调用类的对象，来操作内部的一些类方法，不需要让使用者看到代码工作的细节。 3 ) 、类的继承：类可以从其它类或者元类中继承它们的方法，直接使用。

属性:
---

1：实例属性： 在\_\_init\_\_(self,…)中初始化 内部调用时都需要加上self. 外部调用时用**实例化对象.属性名** 2:类属性： 在\_\_init\_\_()外初始化 在内部用**类名.类属性名**调用 外部既可以用**类名.类属性名**又可以用**实例化对象.类属性名**来调用 3：私有属性： 1）：单下划线_开头：只是告诉别人这是私有属性，外部依然可以访问更改 2）：双下划线__开头：外部不可通过**实例化对象.属性名**来访问或者更改  实际将其转化为了**_类名__属性名_**，只是在内部将变量名修改了，我们仍让可以通过._类名_属性名访问

类属性的修改
------

字典为**可变类型**，而数字是**不可变类型**，因此无法通过这种方式修改。所以在实际开发中应该避免通过实例对象去修改类属 性。  

类的继承：
-----

继承类的构造方法： 1.经典类的写法： 父类名称.\_\_init\_\_(self,参数1，参数2，...) 2. 新式类的写法：super(子类，self).\_\_init\_\_(参数1，参数2，....)

`class``Person(``object``):`

`def``__init__(``self``, name, age):`

`self``.name``=``name`

`self``.age``=``age`

`self``.weight``=``'weight'`

`      def``talk(``self``):`

`print``(``"person is talking...."``)`

`class``Chinese(Person):`

`def``__init__(``self``, name, age, language): ``# 先继承，在重构`

`Person.__init__(``self``, name, age) ``#继承父类的构造方法，`

`也可以写成：super(Chinese,self).__init__(name,age)`

`self``.language``=``language   ``# 定义类的本身属性`

`      def``talk(``self``): ``# 子类 重构方法`

`print``(``'%s is speaking chinese'``%``self``.name)`

方法： \# -*-coding:utf-8-*-  \# 普通方法,类方法,静态方法的区别 \_\_metaclass\_\_ = type class Tst:  name = 'tst' data = 'this is data'  \# 普通方法  def normalMethod(self, name):                   print self.data, name \# 类方法,可以访问类属性  @classmethod  def classMethod(cls, name):                        print cls.data, name \# 静态方法,不可以访问类属性  @staticmethod def staticMethod(name):                          print name

*   三种方法都可以通过实例来调用，但是静态方法和类方法无法访问实例属性，所以更改了tst.data仅对普通方法起了作用
*   普通方法不能通过类名调用，但是静态方法和类方法是可以的
*   普通方法,可以通过self访问实例属性
*   类方法,可以通过cls访问类属性
*   静态方法,不可以访问,通过传值的方式

