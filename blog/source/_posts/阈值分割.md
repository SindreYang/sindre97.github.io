---
title: 阈值分割
tags:
  - cv
categories:
  - 框架
  - opencv
toc: false
date: 2020-03-09 01:26:44
---

# 什么是图像阈值
![image.png](https://blog.mviai.com/images/Fn5xqMS4X6jN0--YE7zgY47l2LfF)
灰度值   0-->255  黑-->白 暗-->亮

# 工作原理
所有阈值算法都将源图像（src）和阈值（thresh）作为输入，并通过将源像素（x，y）的像素值与阈值进行比较来生成输出图像（dst）。如果src（x，y）> thresh，则为dst（x，y）分配一个值。否则，将为dst（x，y）分配一些其他值。

# 二值化(type = THRESH_BINARY )
最简单的阈值形式称为二值化。除了源图像（src）和阈值（thresh）之外，它还使用另一个称为最大值（maxValue）的输入参数。在每个像素位置（x，y），它将像素值src（x，y）与thresh进行比较。如果src（x，y）大于thresh，则将目标图像像素dst（x，y）的值设置为maxValue，否则将其设置为零。
- 二值化（thresh = 0和maxValue = 255）
- ![image.png](https://blog.mviai.com/images/Fg1I9CWbDTr4TuzBnAj_dZBzrYWi)
- 二值化（thresh= 127，maxValue= 255）
- ![image.png](https://blog.mviai.com/images/Fv1pTQtw9FsxHhO9F4v5Ac31Be1w)
- 将maxValue设置为128的二值化
- ![image.png](https://blog.mviai.com/images/FiByv3uqNQ-nmg26XScffnMk7p1M)
- 

# 反向二值化（类型= THRESH_BINARY_INV）
反向二值化与二值化恰好相反。如果相应的源像素大于阈值，则将目标像素设置为零；如果源像素小于阈值，则将目标像素设置为maxValue。
![image.png](https://blog.mviai.com/images/FkGSgV0-6uydZVQlUclO3ZyrSckp)
反向二值化（thresh = 127，maxValue = 0）


# 截断阈值（类型= THRESH_TRUNC）
在这种类型的阈值处理中，如果源像素值大于阈值，则将目标像素设置为阈值（  thresh） 。否则，将其设置为源像素值。maxValue被忽略。
 - 高于阈值（127）的所有值均被设置为127，并且小于或等于127的所有值均保持不变。maxValue被忽略。
 - ![image.png](https://blog.mviai.com/images/FoU2pwY1kupkcwNVxz5AFHkw4rWz)


# 零阈值（类型= THRESH_TOZERO）
在这种阈值化中，如果源像素值大于阈值，则将目标像素值设置为对应的源像素值。否则将其设置为零。maxValue被忽略。
- 零阈值（阈值= 127）
- ![image.png](https://blog.mviai.com/images/FppxkaM7HQq1li844yKJ7nWQgW8d)

# 反转零阈值（类型= THRESH_TOZERO_INV）
在这种阈值处理中，如果源像素值大于阈值，则将目标像素值设置为零。否则，将其设置为源像素值。maxValue被忽略。
将阈值反转为零,低于阈值的数字保留其灰度值，高于阈值的数字为0（边界除外）。边界上的伪影是由于以下事实：边界上的像素值从0过渡到几个像素上的数字值。因此，某些边界像素低于阈值。

![image.png](https://blog.mviai.com/images/FoGfZgexKOvcf4uIuP-7J_hqniG3)


```python

# 导入 opencv
import cv2 

# 读取图片
src = cv2.imread("threshold.png", cv2.IMREAD_GRAYSCALE); 

# 二值化
th, dst = cv2.threshold(src, 0, 255, cv2.THRESH_BINARY); 
cv2.imwrite("opencv-threshold-example.jpg", dst); 

# maxValue设置为128的阈值
th, dst = cv2.threshold(src, 0, 128, cv2.THRESH_BINARY); 
cv2.imwrite("opencv-thresh-binary-maxval.jpg", dst); 

# 设置为127的阈值
th, dst = cv2.threshold(src,127,255, cv2.THRESH_BINARY); 
cv2.imwrite("opencv-thresh-binary.jpg", dst); 

#反二值化
th, dst = cv2.threshold(src,127,255, cv2.THRESH_BINARY_INV); 
cv2.imwrite("opencv-thresh-binary-inv.jpg", dst); 

# 截断阈值
th, dst = cv2.threshold(src,127,255, cv2.THRESH_TRUNC); 
cv2.imwrite("opencv-thresh-trunc.jpg", dst); 

# 零阈值
th, dst = cv2.threshold(src,127,255, cv2.THRESH_TOZERO); 
cv2.imwrite("opencv-thresh-tozero.jpg", dst); 

# 反转零阈值
th, dst = cv2.threshold(src,127,255, cv2.THRESH_TOZERO_INV); 
cv2.imwrite("opencv-thresh-to-zero-inv.jpg", dst); 

```

```C++


// 导入相关包
#include "opencv2/opencv.hpp"

using namespace cv;
using namespace std;

int main( int argc, char** argv )
{

	// 读取图片
	Mat src = imread("threshold.png", IMREAD_GRAYSCALE); 
	Mat dst; 
	
	// 二值化
	threshold(src,dst,0, 255, THRESH_BINARY); 
	imwrite("../opencv-threshold-example.jpg", dst);

	// maxValue设置为128的阈值
	threshold(src, dst, 0, 128, THRESH_BINARY); 
	imwrite("../opencv-thresh-binary-maxval.jpg", dst);
	
	// 设置为127的阈值
	threshold(src,dst,127,255, THRESH_BINARY); 
	imwrite("../opencv-thresh-binary.jpg", dst);
	
	// 反二值化
	threshold(src,dst,127,255, THRESH_BINARY_INV); 
	imwrite("../opencv-thresh-binary-inv.jpg", dst);
	
	// 截断阈值
	threshold(src,dst,127,255, THRESH_TRUNC); 
	imwrite("../opencv-thresh-trunc.jpg", dst);

	//  零阈值
	threshold(src,dst,127,255, THRESH_TOZERO); 
	imwrite("../opencv-thresh-tozero.jpg", dst);

	//反转零阈值
	threshold(src,dst,127,255, THRESH_TOZERO_INV); 
	imwrite("../opencv-thresh-to-zero-inv.jpg", dst);
} 


```